package dev.rubentxu.hodei.pipelines.dsl.execution

import dev.rubentxu.hodei.pipelines.domain.job.JobId
import dev.rubentxu.hodei.pipelines.domain.worker.WorkerId
import dev.rubentxu.hodei.pipelines.dsl.model.*
import dev.rubentxu.hodei.pipelines.port.JobExecutionEvent
import dev.rubentxu.hodei.pipelines.port.JobOutputChunk
import kotlinx.coroutines.channels.Channel
import kotlinx.coroutines.test.runTest
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import kotlin.test.assertEquals
import kotlin.test.assertTrue

/**
 * Tests para el motor principal de ejecuci√≥n Pipeline DSL.
 */
class PipelineEngineTest {

    private val pipelineEngine = PipelineEngine()

    @Test
    fun `should execute simple pipeline successfully`() = runTest {
        // Given
        val pipeline = Pipeline(
            name = "Test Pipeline",
            stages = listOf(
                Stage(
                    name = "Test Stage",
                    steps = listOf(
                        Step.Echo(message = "Hello World")
                    )
                )
            )
        )

        val jobId = JobId("test-job-123")
        val workerId = WorkerId("test-worker-456")
        val outputChannel = Channel<JobOutputChunk>(Channel.UNLIMITED)
        val eventChannel = Channel<JobExecutionEvent>(Channel.UNLIMITED)

        // When
        val result = pipelineEngine.execute(
            pipeline = pipeline,
            jobId = jobId,
            workerId = workerId,
            outputChannel = outputChannel,
            eventChannel = eventChannel
        )

        // Then
        assertTrue(result.success, "Pipeline execution should succeed")
        assertEquals(1, result.stageResults.size, "Should have executed one stage")
        assertEquals("Test Stage", result.stageResults[0].stageName)
        assertTrue(result.stageResults[0].success, "Stage should succeed")
        
        // Cleanup
        outputChannel.close()
        eventChannel.close()
    }

    @Test
    fun `should handle pipeline with multiple stages`() = runTest {
        // Given
        val pipeline = Pipeline(
            name = "Multi-Stage Pipeline",
            stages = listOf(
                Stage(
                    name = "Stage 1",
                    steps = listOf(Step.Echo(message = "Stage 1"))
                ),
                Stage(
                    name = "Stage 2", 
                    steps = listOf(Step.Echo(message = "Stage 2"))
                ),
                Stage(
                    name = "Stage 3",
                    steps = listOf(Step.Echo(message = "Stage 3"))
                )
            )
        )

        val jobId = JobId("multi-stage-job")
        val workerId = WorkerId("test-worker")
        val outputChannel = Channel<JobOutputChunk>(Channel.UNLIMITED)
        val eventChannel = Channel<JobExecutionEvent>(Channel.UNLIMITED)

        // When
        val result = pipelineEngine.execute(
            pipeline = pipeline,
            jobId = jobId,
            workerId = workerId,
            outputChannel = outputChannel,
            eventChannel = eventChannel
        )

        // Then
        assertTrue(result.success)
        assertEquals(3, result.stageResults.size)
        result.stageResults.forEach { stageResult ->
            assertTrue(stageResult.success, "Each stage should succeed")
        }
        
        // Cleanup
        outputChannel.close()
        eventChannel.close()
    }

    @Test
    fun `should execute shell commands`() = runTest {
        // Given
        val pipeline = Pipeline(
            name = "Shell Pipeline",
            stages = listOf(
                Stage(
                    name = "Shell Stage",
                    steps = listOf(
                        Step.Shell(command = "echo 'Shell test'"),
                        Step.Shell(command = "pwd")
                    )
                )
            )
        )

        val jobId = JobId("shell-job")
        val workerId = WorkerId("test-worker")
        val outputChannel = Channel<JobOutputChunk>(Channel.UNLIMITED)
        val eventChannel = Channel<JobExecutionEvent>(Channel.UNLIMITED)

        // When
        val result = pipelineEngine.execute(
            pipeline = pipeline,
            jobId = jobId,
            workerId = workerId,
            outputChannel = outputChannel,
            eventChannel = eventChannel
        )

        // Then
        assertTrue(result.success, "Shell pipeline should succeed")
        assertEquals(1, result.stageResults.size)
        assertTrue(result.stageResults[0].success)
        
        // Cleanup
        outputChannel.close()
        eventChannel.close()
    }

    @Test
    fun `should handle step execution failure gracefully`() = runTest {
        // Given
        val pipeline = Pipeline(
            name = "Failing Pipeline",
            stages = listOf(
                Stage(
                    name = "Failing Stage",
                    steps = listOf(
                        Step.Shell(command = "exit 1") // Command that fails
                    )
                )
            )
        )

        val jobId = JobId("failing-job")
        val workerId = WorkerId("test-worker")
        val outputChannel = Channel<JobOutputChunk>(Channel.UNLIMITED)
        val eventChannel = Channel<JobExecutionEvent>(Channel.UNLIMITED)

        // When
        val result = pipelineEngine.execute(
            pipeline = pipeline,
            jobId = jobId,
            workerId = workerId,
            outputChannel = outputChannel,
            eventChannel = eventChannel
        )

        // Then
        assertFalse(result.success, "Pipeline should fail when step fails")
        assertEquals("Failing Stage", result.failedStage)
        assertNotNull(result.error)
        
        // Cleanup
        outputChannel.close()
        eventChannel.close()
    }

    @Test
    fun `should execute steps with continue on error`() = runTest {
        // Given
        val pipeline = Pipeline(
            name = "Continue On Error Pipeline",
            stages = listOf(
                Stage(
                    name = "Resilient Stage",
                    steps = listOf(
                        Step.Shell(command = "exit 1", continueOnError = true),
                        Step.Echo(message = "This should still execute")
                    )
                )
            )
        )

        val jobId = JobId("continue-error-job")
        val workerId = WorkerId("test-worker")
        val outputChannel = Channel<JobOutputChunk>(Channel.UNLIMITED)
        val eventChannel = Channel<JobExecutionEvent>(Channel.UNLIMITED)

        // When
        val result = pipelineEngine.execute(
            pipeline = pipeline,
            jobId = jobId,
            workerId = workerId,
            outputChannel = outputChannel,
            eventChannel = eventChannel
        )

        // Then
        assertTrue(result.success, "Pipeline should succeed despite failing step")
        assertEquals(1, result.stageResults.size)
        assertTrue(result.stageResults[0].success)
        
        // Cleanup
        outputChannel.close()
        eventChannel.close()
    }

    @Test
    fun `should measure execution duration`() = runTest {
        // Given
        val pipeline = Pipeline(
            name = "Duration Test Pipeline",
            stages = listOf(
                Stage(
                    name = "Quick Stage",
                    steps = listOf(Step.Echo(message = "Quick execution"))
                )
            )
        )

        val jobId = JobId("duration-job")
        val workerId = WorkerId("test-worker")
        val outputChannel = Channel<JobOutputChunk>(Channel.UNLIMITED)
        val eventChannel = Channel<JobExecutionEvent>(Channel.UNLIMITED)

        // When
        val result = pipelineEngine.execute(
            pipeline = pipeline,
            jobId = jobId,
            workerId = workerId,
            outputChannel = outputChannel,
            eventChannel = eventChannel
        )

        // Then
        assertTrue(result.success)
        assertTrue(result.duration > 0, "Should measure execution duration")
        assertTrue(result.stageResults[0].duration > 0, "Should measure stage duration")
        
        // Cleanup
        outputChannel.close()
        eventChannel.close()
    }
}