package dev.rubentxu.hodei.pipelines.dsl.execution

import dev.rubentxu.hodei.pipelines.domain.job.*
import dev.rubentxu.hodei.pipelines.domain.worker.WorkerId
import dev.rubentxu.hodei.pipelines.port.JobOutputChunk
import kotlinx.coroutines.test.runTest
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import kotlin.test.assertEquals
import kotlin.test.assertTrue

/**
 * Tests para el runner que integra jobs del sistema con Pipeline DSL.
 */
class PipelineRunnerTest {

    private val pipelineRunner = PipelineRunner()

    @Test
    fun `should execute script job successfully`() = runTest {
        // Given
        val job = Job(
            id = JobId("script-job-123"),
            definition = JobDefinition(
                payload = JobPayload.Script("println('Hello from script')"),
                environment = mapOf("TEST_ENV" to "test_value")
            )
        )
        val workerId = WorkerId("test-worker")
        val outputChunks = mutableListOf<JobOutputChunk>()

        // When
        val result = pipelineRunner.execute(job, workerId) { chunk ->
            outputChunks.add(chunk)
        }

        // Then
        assertEquals(dev.rubentxu.hodei.pipelines.domain.job.JobStatus.COMPLETED, result.status)
        assertEquals(0, result.exitCode)
        assertNotNull(result.output)
        assertTrue(outputChunks.isNotEmpty(), "Should capture output")
        
        // Verify metrics
        assertNotNull(result.metrics)
        assertTrue(result.metrics!!.containsKey("executionTimeMs"))
        assertTrue(result.metrics!!["executionTimeMs"] as Long > 0)
    }

    @Test
    fun `should execute command job successfully`() = runTest {
        // Given
        val job = Job(
            id = JobId("command-job-456"),
            definition = JobDefinition(
                payload = JobPayload.Command(listOf("echo", "Hello from command")),
                environment = mapOf("PATH" to "/usr/bin")
            )
        )
        val workerId = WorkerId("test-worker")
        val outputChunks = mutableListOf<JobOutputChunk>()

        // When
        val result = pipelineRunner.execute(job, workerId) { chunk ->
            outputChunks.add(chunk)
        }

        // Then
        assertEquals(dev.rubentxu.hodei.pipelines.domain.job.JobStatus.COMPLETED, result.status)
        assertEquals(0, result.exitCode)
        assertNotNull(result.output)
        assertTrue(outputChunks.isNotEmpty())
    }

    @Test
    fun `should execute compiled script job successfully`() = runTest {
        // Given
        val job = Job(
            id = JobId("compiled-job-789"),
            definition = JobDefinition(
                payload = JobPayload.CompiledScript(
                    content = "println('Hello from compiled script')",
                    libraries = listOf("kotlinx-coroutines-core")
                ),
                environment = emptyMap()
            )
        )
        val workerId = WorkerId("test-worker")
        val outputChunks = mutableListOf<JobOutputChunk>()

        // When
        val result = pipelineRunner.execute(job, workerId) { chunk ->
            outputChunks.add(chunk)
        }

        // Then
        assertEquals(dev.rubentxu.hodei.pipelines.domain.job.JobStatus.COMPLETED, result.status)
        assertEquals(0, result.exitCode)
        assertNotNull(result.output)
    }

    @Test
    fun `should handle job execution failure`() = runTest {
        // Given - Command that will fail
        val job = Job(
            id = JobId("failing-job"),
            definition = JobDefinition(
                payload = JobPayload.Command(listOf("false")), // Command that always fails
                environment = emptyMap()
            )
        )
        val workerId = WorkerId("test-worker")
        val outputChunks = mutableListOf<JobOutputChunk>()

        // When
        val result = pipelineRunner.execute(job, workerId) { chunk ->
            outputChunks.add(chunk)
        }

        // Then
        assertEquals(dev.rubentxu.hodei.pipelines.domain.job.JobStatus.FAILED, result.status)
        assertTrue(result.exitCode != 0, "Exit code should indicate failure")
        assertNotNull(result.errorMessage)
        assertTrue(result.errorMessage!!.isNotEmpty())
    }

    @Test
    fun `should capture and forward output in real time`() = runTest {
        // Given
        val job = Job(
            id = JobId("output-job"),
            definition = JobDefinition(
                payload = JobPayload.Script("""
                    println("Line 1")
                    println("Line 2") 
                    println("Line 3")
                """.trimIndent()),
                environment = emptyMap()
            )
        )
        val workerId = WorkerId("test-worker")
        val outputChunks = mutableListOf<JobOutputChunk>()

        // When
        val result = pipelineRunner.execute(job, workerId) { chunk ->
            outputChunks.add(chunk)
        }

        // Then
        assertEquals(dev.rubentxu.hodei.pipelines.domain.job.JobStatus.COMPLETED, result.status)
        assertTrue(outputChunks.isNotEmpty(), "Should capture output chunks")
        
        // Verify output contains expected content
        val allOutput = outputChunks.joinToString("") { String(it.data) }
        assertTrue(allOutput.contains("ðŸš€"), "Should contain pipeline execution messages")
    }

    @Test
    fun `should include comprehensive metrics`() = runTest {
        // Given
        val job = Job(
            id = JobId("metrics-job"),
            definition = JobDefinition(
                payload = JobPayload.Script("println('Metrics test')"),
                environment = mapOf("METRIC_TEST" to "true")
            )
        )
        val workerId = WorkerId("test-worker")

        // When
        val result = pipelineRunner.execute(job, workerId) { }

        // Then
        assertNotNull(result.metrics)
        val metrics = result.metrics!!
        
        // Verify required metrics
        assertTrue(metrics.containsKey("executionTimeMs"))
        assertTrue(metrics.containsKey("stagesExecuted"))
        assertTrue(metrics.containsKey("totalSteps"))
        assertTrue(metrics.containsKey("outputChunksCount"))
        
        // Verify metric values
        assertTrue(metrics["executionTimeMs"] as Long > 0)
        assertTrue(metrics["stagesExecuted"] as Int > 0)
        assertTrue(metrics["totalSteps"] as Int > 0)
    }

    @Test
    fun `should support all job types`() {
        // Given
        val supportedTypes = pipelineRunner.getSupportedJobTypes()

        // Then
        assertTrue(supportedTypes.contains(JobType.SCRIPT))
        assertTrue(supportedTypes.contains(JobType.COMMAND))
        assertTrue(supportedTypes.contains(JobType.COMPILED_SCRIPT))
        
        // Verify can handle each type
        assertTrue(pipelineRunner.canHandle(JobType.SCRIPT))
        assertTrue(pipelineRunner.canHandle(JobType.COMMAND))
        assertTrue(pipelineRunner.canHandle(JobType.COMPILED_SCRIPT))
    }
}