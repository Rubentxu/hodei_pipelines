package dev.rubentxu.hodei.pipelines.dsl.integration

import dev.rubentxu.hodei.pipelines.domain.job.*
import dev.rubentxu.hodei.pipelines.domain.worker.WorkerId
import dev.rubentxu.hodei.pipelines.port.JobOutputChunk
import kotlinx.coroutines.test.runTest
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.Assertions.*
import kotlin.test.assertEquals
import kotlin.test.assertTrue

/**
 * Tests de integración para verificar que Pipeline DSL puede reemplazar completamente 
 * el sistema worker antiguo manteniendo compatibilidad total.
 */
class WorkerIntegrationTest {

    private val pipelineDslStrategy = PipelineDslStrategy()

    @Test
    fun `should convert script job to pipeline DSL automatically`() = runTest {
        // Given - Job que antes usaba KotlinScriptingStrategy
        val job = Job(
            id = JobId("script-conversion-test"),
            definition = JobDefinition(
                payload = JobPayload.Script("""
                    println("Testing script conversion")
                    val result = "success"
                    println("Result: ${'$'}result")
                """.trimIndent()),
                environment = mapOf("SCRIPT_ENV" to "test")
            )
        )
        val workerId = WorkerId("integration-worker")
        val outputChunks = mutableListOf<JobOutputChunk>()

        // When - Ejecutar con nueva estrategia unificada
        val result = pipelineDslStrategy.execute(job, workerId) { chunk ->
            outputChunks.add(chunk)
        }

        // Then - Verificar conversión exitosa
        assertEquals(dev.rubentxu.hodei.pipelines.domain.job.JobStatus.COMPLETED, result.status)
        assertTrue(outputChunks.isNotEmpty(), "Should capture script output")
        assertNotNull(result.metrics)
        assertTrue(result.metrics!!.containsKey("stagesExecuted"))
    }

    @Test
    fun `should convert command job to pipeline DSL automatically`() = runTest {
        // Given - Job que antes usaba SystemCommandStrategy  
        val job = Job(
            id = JobId("command-conversion-test"),
            definition = JobDefinition(
                payload = JobPayload.Command(listOf("echo", "Testing command conversion")),
                environment = mapOf("COMMAND_ENV" to "test")
            )
        )
        val workerId = WorkerId("integration-worker")
        val outputChunks = mutableListOf<JobOutputChunk>()

        // When - Ejecutar con nueva estrategia unificada
        val result = pipelineDslStrategy.execute(job, workerId) { chunk ->
            outputChunks.add(chunk)
        }

        // Then - Verificar conversión exitosa
        assertEquals(dev.rubentxu.hodei.pipelines.domain.job.JobStatus.COMPLETED, result.status)
        assertTrue(outputChunks.isNotEmpty(), "Should capture command output")
        
        // Verificar que se ejecutó como Pipeline DSL
        val allOutput = outputChunks.joinToString("") { String(it.data) }
        assertTrue(allOutput.contains("Testing command conversion"))
    }

    @Test
    fun `should convert compiled script job to pipeline DSL automatically`() = runTest {
        // Given - Job que antes usaba CompilerEmbeddableStrategy
        val job = Job(
            id = JobId("compiled-conversion-test"),
            definition = JobDefinition(
                payload = JobPayload.CompiledScript(
                    content = """
                        println("Testing compiled script conversion")
                        val libraries = listOf("kotlin-stdlib")
                        println("Libraries: ${'$'}libraries")
                    """.trimIndent(),
                    libraries = listOf("kotlin-stdlib-jdk8")
                ),
                environment = mapOf("COMPILED_ENV" to "test")
            )
        )
        val workerId = WorkerId("integration-worker")
        val outputChunks = mutableListOf<JobOutputChunk>()

        // When - Ejecutar con nueva estrategia unificada
        val result = pipelineDslStrategy.execute(job, workerId) { chunk ->
            outputChunks.add(chunk)
        }

        // Then - Verificar conversión exitosa
        assertEquals(dev.rubentxu.hodei.pipelines.domain.job.JobStatus.COMPLETED, result.status)
        assertTrue(outputChunks.isNotEmpty(), "Should capture compiled script output")
    }

    @Test
    fun `should handle pipeline DSL script jobs natively`() = runTest {
        // Given - Script .pipeline.kts que se ejecuta directamente
        val pipelineScript = """
            pipeline("Native Pipeline DSL Test") {
                description("Testing native pipeline DSL execution")
                
                stages {
                    stage("Test Stage") {
                        steps {
                            echo("Hello from native Pipeline DSL!")
                            sh("echo 'Shell command from Pipeline DSL'")
                        }
                    }
                }
            }
        """.trimIndent()

        val job = Job(
            id = JobId("native-pipeline-test"),
            definition = JobDefinition(
                payload = JobPayload.Script(pipelineScript),
                environment = mapOf("PIPELINE_ENV" to "native")
            )
        )
        val workerId = WorkerId("integration-worker")
        val outputChunks = mutableListOf<JobOutputChunk>()

        // When
        val result = pipelineDslStrategy.execute(job, workerId) { chunk ->
            outputChunks.add(chunk)
        }

        // Then
        assertEquals(dev.rubentxu.hodei.pipelines.domain.job.JobStatus.COMPLETED, result.status)
        assertTrue(outputChunks.isNotEmpty())
    }

    @Test
    fun `should maintain backward compatibility with existing job format`() = runTest {
        // Given - Job en formato que usaban workers antiguos
        val legacyJob = Job(
            id = JobId("legacy-compatibility-test"),
            definition = JobDefinition(
                payload = JobPayload.Script("println('Legacy job format')"),
                environment = mapOf(
                    "LEGACY_VAR" to "legacy_value",
                    "PATH" to "/usr/bin:/bin"
                )
            )
        )
        val workerId = WorkerId("legacy-worker")

        // When - Ejecutar con Pipeline DSL
        val result = pipelineDslStrategy.execute(legacyJob, workerId) { }

        // Then - Debe funcionar exactamente igual
        assertEquals(dev.rubentxu.hodei.pipelines.domain.job.JobStatus.COMPLETED, result.status)
        assertEquals(0, result.exitCode)
        assertNotNull(result.output)
    }

    @Test
    fun `should provide better error handling than legacy strategies`() = runTest {
        // Given - Job que falla
        val failingJob = Job(
            id = JobId("error-handling-test"),
            definition = JobDefinition(
                payload = JobPayload.Command(listOf("nonexistent-command")),
                environment = emptyMap()
            )
        )
        val workerId = WorkerId("error-worker")

        // When
        val result = pipelineDslStrategy.execute(failingJob, workerId) { }

        // Then - Error handling mejorado
        assertEquals(dev.rubentxu.hodei.pipelines.domain.job.JobStatus.FAILED, result.status)
        assertNotNull(result.errorMessage)
        assertTrue(result.errorMessage!!.contains("Pipeline DSL execution failed"))
        
        // Verificar métricas incluso en caso de error
        assertNotNull(result.metrics)
        assertTrue(result.metrics!!.containsKey("error"))
    }

    @Test
    fun `should support all job types that legacy strategies supported`() {
        // Given
        val strategy = PipelineDslStrategy()

        // Then - Debe soportar todos los tipos que soportaban las estrategias anteriores
        assertTrue(strategy.canHandle(JobType.SCRIPT), "Should handle SCRIPT jobs")
        assertTrue(strategy.canHandle(JobType.COMMAND), "Should handle COMMAND jobs") 
        assertTrue(strategy.canHandle(JobType.COMPILED_SCRIPT), "Should handle COMPILED_SCRIPT jobs")
        
        // Verificar que es una estrategia universal
        val supportedTypes = strategy.getSupportedJobTypes()
        assertTrue(supportedTypes.contains(JobType.SCRIPT))
        assertTrue(supportedTypes.contains(JobType.COMMAND))
        assertTrue(supportedTypes.contains(JobType.COMPILED_SCRIPT))
    }

    @Test
    fun `should provide migration benefits over legacy system`() = runTest {
        // Given - Job simple para verificar beneficios
        val job = Job(
            id = JobId("migration-benefits-test"),
            definition = JobDefinition(
                payload = JobPayload.Script("println('Migration benefits test')"),
                environment = emptyMap()
            )
        )
        val workerId = WorkerId("migration-worker")

        // When
        val result = pipelineDslStrategy.execute(job, workerId) { }

        // Then - Verificar beneficios de la migración
        
        // 1. Mejor estructura de métricas
        assertNotNull(result.metrics)
        assertTrue(result.metrics!!.containsKey("executionTimeMs"))
        assertTrue(result.metrics!!.containsKey("stagesExecuted"))
        assertTrue(result.metrics!!.containsKey("totalSteps"))
        
        // 2. Mejor manejo de errores
        assertEquals(dev.rubentxu.hodei.pipelines.domain.job.JobStatus.COMPLETED, result.status)
        assertEquals(0, result.exitCode)
        
        // 3. Output estructurado
        assertNotNull(result.output)
        assertTrue(result.output!!.isNotEmpty())
    }

    @Test
    fun `should demonstrate unified architecture benefits`() {
        // Given
        val strategy = PipelineDslStrategy()

        // When - Obtener información de migración
        val migrationInfo = WorkerStrategyFactory.getMigrationInfo()

        // Then - Verificar beneficios arquitecturales
        val replacedStrategies = migrationInfo["replacedStrategies"] as List<*>
        assertTrue(replacedStrategies.contains("KotlinScriptingStrategy"))
        assertTrue(replacedStrategies.contains("SystemCommandStrategy"))
        assertTrue(replacedStrategies.contains("CompilerEmbeddableStrategy"))

        val benefits = migrationInfo["benefits"] as List<*>
        assertTrue(benefits.contains("Single execution path"))
        assertTrue(benefits.contains("Consistent DSL syntax"))
        assertTrue(benefits.contains("Simplified worker architecture"))
        
        assertEquals("PipelineDslStrategy", migrationInfo["newUnifiedStrategy"])
    }
}