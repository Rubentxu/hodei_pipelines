syntax = "proto3";

package dev.rubentxu.hodei.pipelines.proto.v1;

option java_multiple_files = true;
option java_package = "dev.rubentxu.hodei.pipelines.proto";
option java_outer_classname = "ServerWorkerProto";

import "google/protobuf/timestamp.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/empty.proto";

// Tipos de parámetros disponibles
enum ParameterType {
  PARAMETER_TYPE_UNSPECIFIED = 0;
  PARAMETER_TYPE_STRING = 1;
  PARAMETER_TYPE_TEXT = 2;
  PARAMETER_TYPE_BOOLEAN = 3;
  PARAMETER_TYPE_CHOICE = 4;
  PARAMETER_TYPE_PASSWORD = 5;
  PARAMETER_TYPE_FILE = 6;
  PARAMETER_TYPE_ENVIRONMENT = 7;
  PARAMETER_TYPE_JSON = 8;
}

// Tipos de compresión disponibles
enum CompressionType {
  COMPRESSION_NONE = 0;
  COMPRESSION_GZIP = 1;
  COMPRESSION_ZSTD = 2;
}

// Tipos de artefactos disponibles
enum ArtifactType {
  ARTIFACT_TYPE_UNSPECIFIED = 0;
  ARTIFACT_TYPE_LIBRARY = 1;    // JAR, DLL, SO
  ARTIFACT_TYPE_DATASET = 2;    // CSV, Parquet
  ARTIFACT_TYPE_CONFIG = 3;     // Propiedades, YAML
  ARTIFACT_TYPE_RESOURCE = 4;   // Otros recursos
  ARTIFACT_TYPE_DOCKER_IMAGE = 5;  // Imágenes Docker
  ARTIFACT_TYPE_ARCHIVE = 6;    // ZIP, TAR.GZ
}

message JobParameter {
  string name = 1;
  string description = 2;
  ParameterType type = 3;
  bool required = 4;
  oneof value {
    string string_value = 5;
    string text_value = 6;
    bool boolean_value = 7;
    ChoiceParameter choice_value = 8;
    string password_value = 9;
    FileParameter file_value = 10;
    google.protobuf.Struct json_value = 11;
  }
  map<string, string> metadata = 12; // Para metadatos adicionales específicos del tipo
}

message ChoiceParameter {
  repeated string options = 1;
  string selected_value = 2;
}

message FileParameter {
  string file_name = 1;
  bytes content = 2;
  string content_type = 3;
  int64 size = 4;
  string path = 5; // Ruta al archivo en el sistema, alternativa a 'content'
}

enum JobStatus {
  JOB_STATUS_UNSPECIFIED = 0;
  JOB_STATUS_QUEUED = 1;
  JOB_STATUS_RUNNING = 2;
  JOB_STATUS_SUCCESS = 3;
  JOB_STATUS_FAILED = 4;
  JOB_STATUS_CANCELLED = 5;
}

// Enumeración para el estado de un Worker
enum WorkerStatus {
  WORKER_STATUS_UNSPECIFIED = 0;
  WORKER_STATUS_PROVISIONING = 1;
  WORKER_STATUS_READY = 2;
  WORKER_STATUS_BUSY = 3;
  WORKER_STATUS_TERMINATING = 4;
  WORKER_STATUS_FAILED = 5;
}

// Mensajes de identificación
message JobIdentifier {
  string value = 1;
}

message WorkerIdentifier {
  string value = 1;
}

// =====================================
// Servicios para Ejecución de Jobs
// =====================================

// Mensaje para la definición de un Job
message JobDefinition {
  JobIdentifier id = 1;
  string name = 2;
  map<string, string> environment = 4;
  string working_directory = 5;
  repeated JobParameter parameters = 6; // Añadidos los parámetros estructurados

  oneof payload {
    CommandPayload command = 10;
    ScriptPayload script = 11;
  }
}

message CommandPayload {
  repeated string command_line = 1;
}

message ScriptPayload {
  string content = 1;
}

// Mensaje para iniciar la ejecución de un Job
message ExecuteJobRequest {
  JobDefinition job_definition = 1;
  JobExecutionMetadata config = 2;
}

message JobExecutionMetadata {
  int32 timeout_seconds = 1;
  int32 priority = 2;
  bool capture_stdout = 3;
  bool capture_stderr = 4;
  int32 max_output_size = 5; // Tamaño máximo de salida a capturar (en KB)
  map<string, string> labels = 6;
  repeated string allowed_roles = 7; // Roles autorizados para este job ["admin", "ci-engineer"]
  string run_as_user = 8; // Usuario para ejecución del job
  SecurityPolicy security_policy = 9; // Política de seguridad
  repeated Artifact required_artifacts = 10; // Artefactos requeridos para el job
}

// Política de seguridad para jobs
message SecurityPolicy {
  bool allow_network_access = 1; // Permitir acceso a red
  bool allow_file_system_write = 2; // Permitir escritura en filesystem
  repeated string allowed_domains = 3; // Dominios permitidos para acceso de red
  repeated string blocked_commands = 4; // Comandos bloqueados
  map<string, string> environment_restrictions = 5; // Restricciones de variables de entorno
}

// Definición de artefacto (Fase 2: Con caché y compresión)
message Artifact {
  string id = 1; // Identificador único del artefacto
  string name = 2; // Nombre del archivo/artefacto
  ArtifactType type = 3; // Tipo de artefacto
  int64 size = 4; // Tamaño en bytes
  string checksum = 5; // SHA-256 para verificación de integridad
  string path = 6; // Ruta donde debe guardarse en worker
  string version = 7; // Versión del artefacto para caché
  bool compress_transfer = 8; // Si comprimir durante transferencia
  int64 compressed_size = 9; // Tamaño comprimido estimado
}

// Chunk de datos de artefacto para transferencia (Fase 2: Con compresión)
message ArtifactChunk {
  string artifact_id = 1; // ID del artefacto
  bytes data = 2; // Datos del chunk (posiblemente comprimidos)
  int32 sequence = 3; // Número de secuencia (0-based)
  bool is_last = 4; // Indica si es el último chunk
  CompressionType compression = 5; // Tipo de compresión aplicada
  int32 original_size = 6; // Tamaño original antes de compresión
}

// Confirmación de recepción de artefacto (Fase 2: Con estado de caché)
message ArtifactAck {
  string artifact_id = 1; // ID del artefacto
  bool success = 2; // Si la recepción fue exitosa
  string message = 3; // Mensaje de error en caso de fallo
  string calculated_checksum = 4; // Checksum calculado por el worker
  bool cache_hit = 5; // Si el artefacto ya estaba en caché
  ArtifactCacheStatus cache_status = 6; // Estado del caché
}

// Estado del caché de artefactos
message ArtifactCacheStatus {
  bool has_artifact = 1; // Si el worker tiene el artefacto
  string cached_checksum = 2; // Checksum del artefacto en caché
  string cached_version = 3; // Versión en caché
  int64 cache_size_bytes = 4; // Tamaño total del caché
  int32 cached_artifacts_count = 5; // Número de artefactos en caché
}

// Verificación de caché antes de transferencia
message ArtifactCacheQuery {
  repeated string artifact_ids = 1; // IDs de artefactos a verificar
  string job_id = 2; // ID del job que requiere los artefactos
}

// Respuesta de verificación de caché
message ArtifactCacheResponse {
  string job_id = 1; // ID del job
  repeated ArtifactCacheInfo artifacts = 2; // Estado de cada artefacto
}

message ArtifactCacheInfo {
  string artifact_id = 1;
  bool cached = 2; // Si está en caché y es válido
  string cached_checksum = 3; // Checksum en caché (si exists)
  bool needs_transfer = 4; // Si necesita ser transferido
}

// Mensaje para la salida (stdout/stderr) de un Job
message JobOutputChunk {
  JobIdentifier job_id = 1;
  bytes data = 2; // Chunk de datos (stdout/stderr)
  bool is_stderr = 3; // True si es stderr, false si es stdout
  google.protobuf.Timestamp timestamp = 4;
  bool compressed = 5; // Indicador de compresión
  CompressionType compression_type = 6;
}

// Mensaje para el estado de ejecución de un Job en el Worker
message JobExecutionStatus {
  JobIdentifier job_id = 1;
  JobStatus status = 2;
  int32 exit_code = 3; // Código de salida del proceso
  string message = 4; // Mensaje adicional (ej. error)
  ResourceUsage resources = 5; // Métricas de recursos
  map<string, string> custom_metrics = 6; // Métricas personalizadas
}

// Métricas de uso de recursos
message ResourceUsage {
  double cpu_usage = 1; // % CPU utilizado
  uint64 memory_usage = 2; // Memoria utilizada en bytes
  uint64 network_in = 3; // Bytes recibidos por red
  uint64 network_out = 4; // Bytes enviados por red
  uint64 disk_read = 5; // Bytes leídos de disco
  uint64 disk_write = 6; // Bytes escritos a disco
}

// Servicio para la comunicación de ejecución de Jobs entre Server y Worker
service JobExecutorService {
  // Establece un canal bidireccional para la ejecución de jobs.
  // El worker envía su estado y output, y el servidor le envía jobs para ejecutar.
  rpc JobExecutionChannel(stream WorkerToServer) returns (stream ServerToWorker);
}

// Mensaje para el input del Job (server a worker)
message JobInputChunk {
  oneof content {
    ExecuteJobRequest init_request = 1;
    JobParameter parameter = 2;
  }
}

message ControlSignal {
  enum SignalType {
    SIGNAL_TYPE_UNSPECIFIED = 0;
    SIGNAL_TYPE_CANCEL = 1; // Solicita la terminación limpia del job
    SIGNAL_TYPE_PAUSE = 2;  // (Funcionalidad avanzada)
    SIGNAL_TYPE_RESUME = 3; // (Funcionalidad avanzada)
  }
  SignalType type = 1;
  string message = 2;
}

// Mensaje para la salida y estado del Job (worker a server)
message JobOutputAndStatus {
  oneof content {
    JobOutputChunk output_chunk = 1; // Salida del Job
    JobExecutionStatus status_update = 2; // Actualización de estado
  }
}

// Mensaje del Servidor hacia el Worker
message ServerToWorker {
  oneof message {
    ExecuteJobRequest job_request = 1; // Un nuevo job para ejecutar
    ControlSignal control_signal = 2;  // Para enviar señales como "cancelar" o "shutdown"
    ArtifactChunk artifact_chunk = 3;  // Chunk de artefacto para transferir
    ArtifactCacheQuery cache_query = 4; // Verificación de caché de artefactos
  }
}

// Mensaje del Worker hacia el Servidor
message WorkerToServer {
  oneof message {
    // El worker envía el stream de output y estado del job que está ejecutando
    JobOutputAndStatus job_output_and_status = 1;
    // Podríamos incluir aquí también el heartbeat para mantener el canal vivo
    WorkerHeartbeat heartbeat = 2;
    // Confirmación de recepción de artefactos
    ArtifactAck artifact_ack = 3;
    // Respuesta de verificación de caché
    ArtifactCacheResponse cache_response = 4;
  }
}

// Servicio para gestión del ciclo de vida de workers
service WorkerManagementService {
  // Registrar un worker en el servidor
  rpc RegisterWorker (WorkerRegistrationRequest) returns (WorkerRegistrationResponse);

  // Obtener información de un worker específico
  rpc GetWorkerInfo (WorkerIdentifier) returns (WorkerInfo);

  // Listar todos los workers registrados
  rpc ListWorkers (google.protobuf.Empty) returns (stream WorkerInfo);

  // Desregistrar un worker
  rpc UnregisterWorker (WorkerIdentifier) returns (google.protobuf.Empty);
}

// Servicio para estadísticas del sistema
service SystemStatsService {
  // Obtener estadísticas del sistema
  rpc GetSystemStats (google.protobuf.Empty) returns (SystemStatsResponse);
}

// Respuesta de estadísticas del sistema
message SystemStatsResponse {
  int32 total_workers = 1;
  int32 active_workers = 2;
  int32 total_jobs = 3;
  int32 queued_jobs = 4;
  int32 running_jobs = 5;
  ResourceUsage system_resources = 6;
}

// Mensajes para gestión de workers
message WorkerRegistrationRequest {
  WorkerIdentifier worker_id = 1;
  string worker_name = 2;
  string auth_token = 3;
  map<string, string> capabilities = 4;
  string worker_version = 5;
  int32 max_concurrent_jobs = 6;
  repeated string tags = 7; // Etiquetas para filtrado
}

message WorkerRegistrationResponse {
  bool success = 1;
  string message = 2;
  string session_token = 3;
  int32 heartbeat_interval_seconds = 4;
}

message WorkerHeartbeat {
  WorkerIdentifier worker_id = 1;
  WorkerStatus status = 2;
  int32 active_jobs_count = 3;
  google.protobuf.Timestamp timestamp = 4;
  ResourceUsage system_resources = 5; // Recursos del sistema
  map<string, string> system_info = 6; // Información adicional del sistema
}

message WorkerInfo {
  WorkerIdentifier id = 1;
  string name = 2;
  WorkerStatus status = 3;
  map<string, string> capabilities = 4;
  google.protobuf.Timestamp registered_at = 5;
  google.protobuf.Timestamp last_heartbeat = 6;
  int32 active_jobs_count = 7;
  int32 max_concurrent_jobs = 8;
  repeated string tags = 9;
  ResourceUsage last_resources = 10; // Último reporte de recursos
}